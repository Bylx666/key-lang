# 模块化

需要注意的是，Key并不会缓存你的模块。如果你在一个程序中对同一文件使用了两次mod语句，Key会执行两次对应的程序并得到两个独立的模块。
同样的，每个ks模块中引用的模块也都分别独立，这样的话对同一个模块的上下文就不会因为多个模块对其的修改行为而乱套。

只能导出函数和struct。如果允许导出变量的话会导致用户无法操控其多线程逻辑。

## 导出
```
// 导出函数，对应let f()
mod. f(a) {
  print(a)
}

// 导出结构，对应struct
mod: MyStruct {
  a:20
}

// 导出方法，对应impl
mod:: MyStruct {
  test() {
    
  }
}
```

需要注意的是，导出方法并不需要导出结构，但只要导出结构，外界就可以直接通过属性名构造此结构。

## 声明

文件名后的箭头前不可空格

mod test.dll> my_mod
mod test.ksm> my_mod
mod C:\d\e.ksm> my_mod

mod test.ks> my_mod

和extern很像，不管你声明在多深的作用域，都可以全局调用。但如果把mod声明在函数里，每次调用此函数都会再次加载这个模块，大部分时候这不是期待的结果；所以最好还是声明在最外面。

## 使用

`-.`和·`-:`
my_mod-.myfunc();
my_mod-:MyStruct;

## 原生模块 Native Mods

本来想支持c的，但c和rust历史代沟太大了，而且支持c就要大幅降低rust程序员的编程体验，只好放弃了。
